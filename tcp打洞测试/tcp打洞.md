###NAT下的TCP打洞
#####1.怎么实现打洞
> 要实现 AB直接的通讯，就必须进行以下3步：
> 1.A首先连接互联网上的服务器S并发送一条消息（对于UDP这种无连接的协议其实直接初始会话发送消息即可），这样S就获取了A在互联网上的实际终端（发送消息的IP和端口号）。
> 2.接着 B也进行同样的步骤，S就知道了AB在互联网上的终端（这就是“打洞”）。
> 3接着S分别告诉A和B对方客户端在互联网上的实际终端，也即S告诉A客户B的会话终端，S告诉B客户A的会话终端。这样，在AB都知道了对方的实际终端之后，就可以直接通过实际终端发送消息了（因为先前双方都向外发送过消息，路由上已经有允许数据进出的消息通道）。

#####2.TCP相对于UDP的问题
```
1. 用UDP来实现以上3步不存在什么理论上的问题，因为UDP是无连接的协议，它允许socket进行“多对一”的通讯（即几个具有不同IP和端口号的socket向一个接收socket发送消息）。但是使用TCP就出现了问题：在一般情况下，TCP socket不允许在已经建立连接的端口上再进行监听和使用该本地端口。换句话说，当AB连接上服务器S后，S将AB的实际终端告诉对方，下一步本该是AB利用对方的实际终端进行直连，但这时你会发现对方的实际终端已经被占用了（就是各自连接到服务器S的会话占用了终端），无法同时listen和 connect。
  >>>setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, &flag, len)就能解决问题1 
2. NAT会阻止来的SYN包
  >>>下面都是解决问题2的方法
```
#####3.论文说了啥
> 他说:在最近提出的方法中.所有的方法都是,两个终端发起一个TCP连接(即:socket的connect函数),终端向外发出的SYN包在自己的NAT上创建必要的NAT状态
- 1.STUNT方法:终端双方都主动发送SYN请求TCP连接包,并且
ttl要刚好能穿过各自的NAT就丢弃.通过侦听原始套接字上的SYN,了解到初始的TCP序列号.通过序列号来SYNACK来欺骗双方.
第二种方法，只有一个终端发出一个低TTL的SYN包，接着该发送者取消该连接企图，并在相同的地址和端口创建一个被动的TCP套接字。然后，另一个终端初始化一个正常的TCP连接，终端需要挑选一个恰当的TTL，而且NAT也不能把ICMP错误当作致命错误。它也需要NAT在一个向外发的SYN后，接收一个向内发的SYN，但包的序号也不是普通的那种。
- 2.NATBlaster
 每个终端发出一个低TTL的SYN，并记住协议栈所使用的TCP序号。与前面的类似，SYN包在网络中被丢弃。两台主机之间交换各自的序号，并且每台主机手工产生一个对方期望收到的SYNACK包。手工产生的包通过原始套接字注入网络。然而，这并不等同于欺骗，因为该包中的源地址与注入该包的终端地址匹配。一旦收到SYNACK，ACK就被交换了，从而完成了连接建立。与第一种STUNT方法一样，该方法也需要终端准确地选择TTL值，也需要NAT忽略ICMP错误和NAT改变SYN包序号的失败。而且，（该方法）也需要NAT允许一个外发的SYN之后紧跟一个外发的SYNACK——非正常的另一个序号的包。
- 3.Peer-to-Peer NAT
  两个终端都通过发送SYN包来创建一个连接。如果SYN包在网络中交叉（穿过），这两个终端协议栈都用SYNACK包应答从而建立连接。如果在对方的SYN包离开它的NAT之前，一个终端的SYN包到达该终端的NAT而被丢弃，那么，第一个终端的协议栈会在TCP同时打开之后而结束（关闭），而另一个终端则会按照正常流程打开。接下来的情况，链路中的包看起来像第二种STUNT方法，没有底TTL，也没有相关的ICMP。然而，该方法并没有用端口预测，如果使用的话，该方法可以从中获益。与第二种STUNT方法一样，该方法需要NAT允许在一个外发的SYN之后紧跟一个内发的SYN，而且，该方法需要终端在一个循环中不停的尝试重连，直到超时。如果不是SYN包被丢弃，而是NAT返回一个TCP RST，那这种方法将陷入包泛滥的境地，直到超时。

####论文小总结:
 **  两个终端TCP连接互发syn包时,一般(90%)都会被对方的nat阻拦.论文中就是说我们设定syn包的ttl要让它穿过我们的nat,然后我们获取tcp请求生成的绝对序列号让对方知道,来生成假的synack这样tcp握手成功了.然后就发数据.
 要求:
 1.NAT忽略ICMP错误.2.NAT不能改变SYN包序列号,3.ttl值的设定
  几个疑点:
  1.ttl设置要必须穿过自己的nat?WHY??因为我们一调用socket的connect他就会生成序列号,和syn包,对方知道这些就可以合成一个synack了.难道是为了让他生成NAT的状态,当对方发包来,NAT就不拒绝了
   2.论文中提到了隐藏在几个nat后的终端,待测试.
  **
#####4.网上问题的解决
1.现在假设客户A想和客户B建立TCP连接。
>首先还是 AB分别和服务器S分别建立连接，S记录AB的互联网实际终端。然后S分别向AB发送对方的实际终端。接着，从A和B向S连接时使用的端口，AB都异步调用connect函数连接对方的实际终端（就是S告诉的终端），同时，AB双方都在同一个本地端口监听到来的连接（也可以先监听，再connect更好）。由于双方都向对方发送了connect请求（假设各自的SYN封包已经穿过了自己的NAT），因此在对方connect请求到达本地的监听端口时，路由器会认为这个请求是刚刚那个connect会话的一部分，是已经被许可的，本地监听端口就会用SYN-ACK响应，同意连接。这样，TCP穿透NAT的点对点连接就成功了。

2.实现过程如下（请参照源代码）：
>1、 S启动两个网络侦听，一个叫【主连接】侦听，一个叫【协助打洞】的侦听。
2、 A和B分别与S的【主连接】保持联系。
3、 当A需要和B建立直接的TCP连接时，首先连接S的【协助打洞】端口，并发送协助连接申请。同时在该端口号上启动侦听。注意由于要在相同的网络终端上绑定到不同的套接字上，所以必须为这些套接字设置 SO_REUSEADDR 属性（即允许重用），否则侦听会失败。
4、 S的【协助打洞】连接收到A的申请后通过【主连接】通知B，并将A经过NAT-A转换后的公网IP地址和端口等信息告诉B。
5、 B收到S的连接通知后首先与S的【协助打洞】端口连接，随便发送一些数据后立即断开，这样做的目的是让S能知道B经过NAT-B转换后的公网IP和端口号。
6、 B尝试与A的经过NAT-A转换后的公网IP地址和端口进行connect，根据不同的路由器会有不同的结果，有些路由器在这个操作就能建立连接（例如我用的TPLink R402），大多数路由器对于不请自到的SYN请求包直接丢弃而导致connect失败，但NAT-A会纪录此次连接的源地址和端口号，为接下来真正的连接做好了准备，这就是所谓的打洞，即B向A打了一个洞，下次A就能直接连接到B刚才使用的端口号了。
7、 客户端B打洞的同时在相同的端口上启动侦听。B在一切准备就绪以后通过与S的【主连接】回复消息“我已经准备好”，S在收到以后将B经过NAT-B转换后的公网IP和端口号告诉给A。
8、 A收到S回复的B的公网IP和端口号等信息以后，开始连接到B公网IP和端口号，由于在步骤6中B曾经尝试连接过A的公网IP地址和端口，NAT-A纪录了此次连接的信息，所以当A主动连接B时，NAT-B会认为是合法的SYN数据，并允许通过，从而直接的TCP连接建立起来了。

####网上的方法小总结
 **网上的这些方法都大同小异,啥子意思楠.就是说,你的nat不是要阻塞我的syn包嘛.好,现在我互相connect对方或者一方connect,虽然我的syn包被对方拒绝了,但是对方再次connect我的时候,给我发syn包,我的nat就认为它合法.
 疑问:怎么感觉比论文的方法简单多了,不知道靠不靠谱.网上已找到代码,但是是在win下的,但可以测试一下,
 **
#####5.NAT的种类:
> 这里先了解了一下NAT的类型：
NAT设备的类型对于TCP穿越NAT,有着十分重要的影响,根据端口映射方式,NAT可分为如下4类,前3种NAT类型可统称为cone类型。
(1)全克隆( Full Cone) : NAT把所有来自相同内部IP地址和端口的请求映射到相同的外部IP地址和端口。任何一个外部主机均可通过该映射发送IP包到该内部主机。
(2)限制性克隆(Restricted Cone) : NAT把所有来自相同内部IP地址和端口的请求映射到相同的外部IP地址和端口。但是,只有当内部主机先给IP地址为X的外部主机发送IP包,该外部主机才能向该内部主机发送IP包。
(3)端口限制性克隆( Port Restricted Cone) :端口限制性克隆与限制性克隆类似,只是多了端口号的限制,即只有内部主机先向IP地址为X,端口号为P的外部主机发送1个IP包,该外部主机才能够把源端口号为P的IP包发送给该内部主机。
(4)对称式NAT ( Symmetric NAT) :这种类型的NAT与上述3种类型的不同,在于当同一内部主机使用相同的端口与不同地址的外部主机进行通信时, NAT对该 的映射会有所不同。对称式NAT不保证所有会话中的私有地址和公开IP之间绑定的一致性。相反,它为每个新的会话分配一个新的端口号。

**举个栗子**
现在NAT下有2个内部ip:192.168.3.1与192.169.3.2.
1.全克隆:把这两个ip地址映射成外部IP地址.192.168.3.1:50...通过NAT后外部(192.168.3.1):50.并且外面的主机如果知道我的外部(192.168.3.1)就可以给我发包了.
2.限制性克隆:与上条相同,多了一条.我要先向外面的主机发包,外面的主机才能向我发包.
3.端口限制性克隆:与上条类似,我要向外面的主机端口P发包,外面的主机才能向我端口P发包.
4.对称式NAT:我192.168.3.2通过端口号100向外面的主机A,B发包,我通过NAT映射成的外部ip地址,但是对A和B我的外部地址,端口不同.
